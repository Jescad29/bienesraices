* Iniciar el servidor:  
        - node index.js si no tienes script
        - npm start server (En caso de tener un scrip en package.json)

* pug:    
    - Una dependencia que utilizaremos es pug: la cual nos simplifica el escribir html,
      poner clases o ID y aparte podemos integrar cosas como bucles(if, else etc..) tambien
      e incluir variables de manera rapida.
    - Tambien es muy limpia su sintaxis.
    - Hay que cuidar la identaci√≥n.

* MVC (Model View Controller)
    Es un patron de arquitectura de software que permite la separaci√≥n de obligaciones de cada pieza de tu c√≥digo. 

    - Enfatiza la separaci√≥n de la l√≥gica de programaci√≥n con la presentaci√≥n. 

    Ventajas de MVC:
        - MVC no mejora el performance del c√≥digo, tampoco da seguridad; pero tu c√≥digo tendr√° un mejor orden y ser√° f√°cil de mantener. 
        - En un grupo de trabajo, el tener el c√≥digo ordenado permite que m√°s de una persona pueda entender que es lo que hace cada parte de √©l.
        - Aprender MVC, har√° que otras tecnolog√≠as como Laravel, Nest, Rails, Django, Net Core, Spring Boot te sean m√°s sencillas de aprender todos utilizan paradigmas muy similares.

        M = Model o Modelo.
        V = View o Vista.
        C = Controller o Controlador.

        Modelo en MVC: Encargado de todas la interacciones en la base de datos, obtener datos, actualizarlos y eliminar.
            - El modelo se encarga de consultar una base de datos, obtiene la informaci√≥n,
              pero no la muestra, eso es trabajo de la vista. 
            - El modelo tampoco se encarga de actualizar la informaci√≥n directamente; es el 
              Controlador quien decide cu√°ndo llamarlo.
        Vista en MVC: Se encarga de todo lo que se ven en pantalla (HTML).
            - Node soporta m√∫ltiples Template Engine como son EJS, Pug, Handlebars.
            - Pero si utilizamos Node como API e implementamos React, Vue, Angular y Svelte, estos ser√≠an tu vista.
            - El Modelo consulta la base de datos, pero es por medio del Controlador que se decide que Vista hay que llamar y que datos presentar.
        Controlador en MVC: Es el que comunica modelo y vista; antes de que el Modelo consulte, la base de datos el Controlador es el encargado de llamar un Modelo en especifico. 
            - Una vez consultado el Modelo, el controlador recibe esa informaci√≥n, manda llamar a la vista y le pasa la informaci√≥n.
            - El controlador es el que manda a llamar la vista y modelos, que se requieren en cada parte de tu aplicaci√≥n. 

        Router en MVC: Es el encargado de registrar todas las URL¬¥s o Endpoints que va a
        soportar nuestra aplicaci√≥n.

        Ejemplo: Si el Usuario accede a /clientes el router ya tiene registrada esa ruta y un controlador con una funci√≥n que sabe que Modelo debe llamar y que vista mostrar cuando el usuario visita esa URL.

    Tailwind:
    Para instalar tailwind e implementarlos.

        Primero: Instalamos Tailwind como dependencia de desarrollo (solo se utiliza en el desarrollo y no en produccion o cuando se esta ejecutando la app.)
            - npm i -D tailwindcss

        Segundo: Crearemos una caperta css en nuestra carpeta public y dentro abriremos un archivo tailwind.css en donde escribiremos las siguientes lineas:

                @tailwind base;
                @tailwind components;
                @tailwind utilities;
        
        Tercero: Metemos el comando:

                npx tailwindcss init -p  
                - Esto lo que va a hacer es que nos va a crear dos archivos (tailwind.config.js y postcss.config.js) 
                
                ---- BUG ----
                    Aqui tuvimos un error y lo que hicimos fue eliminar node_modules con:
                    -   rm -rf node_modules package-lock.json

                    Limpiamos el cache corrupto
                    -   npm cache clean --force

                    Instalamos las dependencias nuevamente:
                    -   npm install

                    Solucion: El problema es que tailwind 4 ya no tiene el comando tailwindcss init
                    por que ya no ocupa el archivo tailwind.config.js
                    - Para que funcionara tuvimos que bajar el versionado 
                        npm install -D tailwindcss@3.3.5
                
                    - Y luego ya podemos meter el siguiente comando con normalidad:
                        npx tailwindcss init -p

    Crear un Layout Principal:
        1.- Antes que nada tenemos que crear nuestra carpeta layout/ en la carpeta views de nuestro proyecto y creamos el archivo index.pug.
            Nota: Podemos crear nuestro doctype html con el signo " ! ",

        2.- Para indicar a nuestros templates que lo van a utilizar lo hacemos por medio de extends la cual es una directiva de pug.

            extends ../layout/index

        3.- Si vamos directamente a http://localhost:3000/auth/login y recargamos, nos va a aparecer el siguiente error:

            Error: C:\Users\vic_s\Desktop\proyectos_directos\proyectos_node\bienesraices_mvc\views\auth\login.pug:3:1

            Only named blocks and mixins can appear at the top level of an extending template.
            
            Nota: Esto pasa por que en nuestro archivo login.pug tenemos codigo que nos marca error ya que no estamos indicando en nuestro template con pug el bloque que estar libre para ser utilizado

            main(class="mx-auto container mt-10 px-2")
                block contenido

            y en nuestro archivo index.pug si utilizamos nuestro extends y le agregamos nuestro block contenido.

                block contenido
                    div 
                        h2.text-center.text-6xl Inicia sesi√≥n 

            y lo mejor es que puedes tener diferentes bloques, puedes tener uno para sidebar, para el footer, etc. de esa forma no duplicamos codigo y los cambios se hacen mas rapidos
    Routing entre paginas:

        Nota: Recuerda que el routing para navegar entre paginas debes tomar nuestro endpoint general de nuestro archivo index.js y de nuestro archivo routes 

            app.use('/auth', usuarioRoutes); En este caso tomaremos /autch 
            router.get('/login', formularioLogin); y en este tomaremos /login

            De esa manera obtenemos la ruta  /autch/login que utilizaremos en nuestra vista dentro de nuestro menu o algun boton que redireccione. 

                a.text-gray-500.text-xs(href="/auth/login") ¬øYa tienes cuenta? Inicia Sesi√≥n
    ORM: ¬øQue es un orm?
        Son las iniciales de Object Relational Mapping y es una tecnica que se utiliza donde los datos de una base de datos son tratados como objetos, utilizando un 
        paradigma de programaci√≥n Orientada a Objetos.

        Node.js tiene una gran cantidad de ORM's que se instalan como librer√≠a.
        En MVC, un ORM se relaciona bastante con el Modelo.

        Ventajas.
            - Comenzar a crear aplicaciones que utilicen bases de datos, sin necesidad de escribir c√≥digo SQL y tampoco saber sobre modelado de bases de datos. 

            - Velocidad en desarrollo ya que tienen una gran cantidad de m√©todos para crear, listar, actualizar o eliminar datos.

            - La mayor√≠a cuentan con todas las medidas de seguridad.

            ORM's en node
                - Prisma
                - Sequelize
                - Bookshelf.js
                - Mongoose
                - TypeORM
    
    Conectar una app a nuestra base de datos:
        
        1.- Instalar dependencias:
            npm i Sequelize mysql2
        2.- Creamos la carpeta config y el archivo db.js donde tendremos la configuracion de la base de datos. 
        3.- En el archivo db.js
            - Importamos las dependencia: import Sequelize from "sequelize";
            - creamos una instancia const db = new Sequelize()    La cual toma 4 parametros nombre de la base de datos, el usuario, el password y un objeto de configuraci√≥n al cual podemos pasarle mas opciones. 
        4.- Configuramos nuestra base de datos:
                Alerta!!!! Estos datos son sencibles a si que acuerdate protegerlos 
                utilizando variables de entorno puedes utilizar la biblioteca dotenv y mandas a llamar tus variables entorno con process.

                const db = new Sequelize('bienesraices_node_mvc', 'root', '', {
                    host: 'localhost',
                    port: 3306,
                    dialect: 'mysql',
                    define: {
                        timestamps: true
                    },
                    pool: {
                        max: 5,
                        acquire: 3000,
                        idle: 10000
                    }
                });

                - ( timestamps: true ) Nos ayuda a que cuando un usaurio se registra, nos agrega dos columnas extra a la tabla de usuarios con la fecha y la hora de cuando fue creado. 
                - (pool o conexion pool) Cada que yo visito un sitio web, si requiero conectarme a la base de datos se va a crear una conexion a la base de datos
                la conexion a la base de datos es algo que consume muchos recursos entonces este pool de conexiones eso es lo que hace, configura como es que 
                va a ser el comportamiento para conexiones nuevas o existentes al igual que mantener o reutilizar las conexiones que esten vivas
                    - max y min ( max: 5 ) Es el maximo de conexiones que va a hacer
                    - acquire 30000 Es el tiempo que va a pasar tratando de elaborar una conexion antes de que marque error en este caso 3 segundos
                    - idle es el tiempo que le da a una conexion que no se esta utilizando finalice en este caso 10 segundos para liberar espacio o memoria.
        5.- Mandamos a llamar nuestra base de datos en nuestro archivo principal

            - import db from './config/db.js'

            // Conexion a la base de datos en este caso creamos un try-catch con logs para saber si la conexion estuvo correcta o no. 

                try {
                    await db.authenticate(); 
                    console.log('Conexi√≥n Correcta a la Base de datos')
                } catch (error) {
                    console.log('Error en la conexion a la base de datos')
                }

    - Difiniendo un modelo: 
        - Creamos nuestra carpeta models en la raiz de nuestro proyecto y creamos el archivo Usuarios.js
        - Dentro de nuestro archivo usuarios importamos 'sequelize'
            
            import { DataTypes } from 'sequelize';  Es lo mismo si importamos sequelize en ves de { DataTypes }
            import db from '../config/db'; Tambien llamamos a nuestra configuracion de la base de datos de archivo db.js de config

            y Sobre esa instancia que va a tener esa conexion utilizamos define('') que es la forma en la que defines un nuevo modelo y dentro definimos el nombre que va a llevar nuestra tabla define('usuarios') y creamos el objeto con la configuracion de las diferentes columnas y tipos de datos que va a tener esta tabla de usuarios.

                const Usuario = db.define('usuarios', {
                    ......... Columnas .........
                }); 
        -   Crear columnas en nuestra tabla.
                
                const Usuario = db.define('usuarios', {
                    nombre: {
                        type: DataTypes.STRING,
                        allowNull: false
                    },
                    email: {
                        type: DataTypes.STRING,
                        allowNull: false
                    },
                    password: {
                        type: DataTypes.STRING,
                        allowNull: false
                    },
                    token: DataTypes.STRING,
                    confirmado: DataTypes.BOOLEAN
                });

            Nota: No todos los datos son soportados leer la documentacion.
                https://sequelize.org/api/v6/variable/index.html#static-variable-DataTypes

        - Como podemos leer los datos que nos envia un formulario para guardarlos en una base de datos o hacer uso de esa informaci√≥n, como express es muy minimalista tenemos que activar esta parte, ya que los datos se van a encontrar en req.body
        si nosotros ponemos un console log en nuestro controlador

            const registrar = async (req, res) => {    Nos va a lanzar undefind por que aun
                console.log(req.body)                  no podemos recibir datos.
            };

            Para recibir datos lo que tenemos que hacer es ocupar use:
                // Habilitar lectura de datos de formularios.
                app.use( express.urlencoded({extended: true}))

            de esta manera ya estariamos recibiendo un dato como este:
            Conexi√≥n Correcta a la Base de datos
                El servidor esta funcionando en el puerto 3000
                Registrando ...... .... ... . 
                {
                  nombre: 'Victor',
                  email: 'victor@jes.com',
                  password: 'victor123',
                  repetir_password: 'victor123'
                }

            - Y para agregarlo a nuestra base de datos como un nuevo usuario ?

                    const usuario = await Usuario.create(req.body)
                        res.json(usuario)

            - Y como agregamos una validacion de datos?
                Podemos utilizar express-validator 
                npm i express-validator

                - utilizamos las validaciones de express-validator al momento de crear al usuario

                // Validaci√≥n
                await check('nombre').notEmpty().withMessage('El nombre es obligatorio').run(req)
                await check('email').notEmpty().withMessage('El correo es obligatorio').isEmail().          withMessage('Eso no parece un email').run(req)
                await check('password').isLength({ min: 6 }).withMessage('El Password debe ser de al            menos 6 caracteres').run(req)
                await check('repetir_password').custom((value, { req }) => value === req.body.          password).withMessage('Los password no son iguales').run(req)
    
                let resultado = validationResult(req)

                - Y dentro de nuestro archivo pug creamos un if para que valide la informacion y cree las alertas necesarias con un each y nos retorne esta parte : errores: [{msg:'El Usuario ya esta Registrado'}],

                        if errores 
                            div(class="max-w-md mx-auto my-10")
                                each error in errores 
                                    p.bg-red-600.text-white.uppercase.text-xs.text-center.p-2.mb-1.font-bold= error.msg

            - Auto llenado de campo y verificar si el usuario esta duplicado por medio del email. 
                - Utilizamos la operacion ternaria dentro de " value = " para asignar un valor dependiendo de si usuario existe o no.

                input#email.w-full.px-3.py-2.border.border-gray-300.rounded-md.placeholder-gray-400(placeholder="Tu email" type="email" name="email" value= usuario? usuario.email : '')

                input(type="text", name="nombre", value=usuario ? usuario.nombre : '')
                input(type="email", name="email", value=usuario ? usuario.email : '')
                input(type="password", name="password")  // ‚Üê Este NO se rellena

                    usuario.controller.js/

                    //Extraer los datos
                    const {nombre, email, password} = req.body

                    // Verficar que el usuario no este duplicado
                    const existeUsuario = await Usuario.findOne({ where: { email } })

                    if(existeUsuario) {
                        return res.render('auth/registro', {
                            pagina: 'Crear Cuenta',
                            errores: [{msg:'El Usuario ya esta Registrado'}],
                            usuario: {
                                nombre: req.body.nombre,
                                email: req.body.email
                            }
                        })
                    }

                - Si el usuario intenta registrarse con un email existente: const existeUsuario = await Usuario.findOne({ where: { email } });
                                if (existeUsuario)

                - Se vuelve a mostrar el formulario (auth/registro) " return res.render('auth/registro', {" 

                - Se pasan los datos que ya hab√≠a escrito (nombre, email)
                        usuario: {
                            nombre: req.body.nombre,
                            email: req.body.email
                        }

                - Y puedes rellenar autom√°ticamente esos campos en el HTML/Pug usando ternarias como:
                    input(type="text", name="nombre", value=usuario ? usuario.nombre : '')
                    input(type="email", name="email", value=usuario ? usuario.email : '')
                    input(type="password", name="password")  // ‚Üê Este NO se rellena

                üí° Buenas pr√°cticas
                ‚úîÔ∏è S√≠ debes guardar y reusar nombre, email, tel√©fono, etc.
                ‚ùå Nunca debes rellenar autom√°ticamente el password, por seguridad.


            - Hashear nuestra contrase√±a.
                Para hashear nuestra contrase√±a 


                - Creamos un hook :
                    üîπ ¬øQu√© es un hook?
                        Un hook es un gancho o funci√≥n que se ejecuta autom√°ticamente antes o despu√©s de ciertas operaciones en Sequelize, como crear, actualizar o borrar un registro.

                        En este caso, est√°s usando el hook beforeCreate.

                        hooks: {
                                beforeCreate: async function(usuario) {
                                    const salt = await bcrypt.genSalt(10)
                                    usuario.password = await bcrypt.hash(usuario.password, salt);
                                    }
                                }

                    1Ô∏è‚É£ beforeCreate: async function(usuario)

                        - Define un hook que se ejecuta antes de que Sequelize cree un nuevo registro en la base de datos.- 
                        - La funci√≥n recibe como argumento el objeto usuario que est√° a punto de guardarse.

                    2Ô∏è‚É£ const salt = await bcrypt.genSalt(10)

                        - Genera un salt (valor aleatorio) con 10 rondas de complejidad, usado para hacer m√°s seguro el hash de la contrase√±a.
                        - El salt ayuda a que el mismo password no genere el mismo hash para diferentes usuarios.

                    3Ô∏è‚É£ usuario.password = await bcrypt.hash(usuario.password, salt)

                        - Convierte el usuario.password (texto plano que el usuario escribi√≥) en un hash seguro usando bcrypt y el salt generado.
                        - Despu√©s de esto, el password almacenado en la base de datos ser√° un hash, no el texto plano, lo cual es fundamental para la seguridad.     

                    ¬øQu√© logras con esto?
                        Que siempre que se crea un usuario nuevo, su contrase√±a sea encriptada autom√°ticamente antes de guardarse, sin tener que preocuparte por hacerlo manualmente cada vez.

        - Generar un token √önico para que el usuario confirme su cuenta
            1.- Ir a la raiz del proyecto y crear una carpeta llamada helpers, ahi se van a alojar funciones reutilizables en diferentes lugares.

            2.- crear el archivo tokens.js

            3.- la siguiente linea nos ayudara a crearlo con base en la fecha en milisegundo que se creo el usuario y un numero aleatorio, de esta manera no tendremos que instalar ninguna libreria. 

                const generarId = () => Date.now().toString(32) + Math.random().toString(32).substring(2);

                - ‚úÖ Date.now().toString(32)
                - Date.now() devuelve el n√∫mero de milisegundos desde el 1 de enero de 1970 (Epoch time).

                - .toString(32) convierte ese n√∫mero a una cadena en base 32, es decir, usando d√≠gitos del 0-9 y letras a-v.

                - Date.now() => 1722917259931
                Date.now().toString(32) => '1mvm2ex3r' (esto cambia cada segundo)

                Math.random().toString(32)
                Math.random() genera un n√∫mero decimal entre 0 y 1 (por ejemplo, 0.715838...).

                .toString(32) lo convierte a base 32. El resultado siempre empieza con 0. porque es un n√∫mero menor que 1.

                .substring(2) elimina el 0. y deja solo los caracteres aleatorios.

                Lo que nos devuelve la funcion completa es una combinacion de los dos resultados. 
                    generarId() => '1mvm2ex3r' + 'v81e9q' => '1mvm2ex3rv81e9q'

                ‚úÖ ¬øPor qu√© base 32?
                Usar base 32 genera una cadena m√°s compacta que usar base 10 o base 16, aprovechando m√°s caracteres con menos longitud.


    - Envio de email de confirmacion.
        - Lo primero es crear nuestra vista de "Cuenta creada correctamente" y notificando el email de confirmacion enviado. 
            - Creamos primero nuestro archivo mensaje.pug o como lo querramos nombrar que es la vista que se vera una vez se haya registrado el usuario exitosamente. 

                extends ../layout/index.pug

                block contenido
                    div.py-10
                        h1.text-4xl.my-10.font-extrabold.text-center Bienes
                            span.font-normal Raices 
                        h2.text-center.text-2xl.font-extrabold= pagina

                        p.text-xl.font-bold.text-center.my-10=mensaje
            
            - En nuestro controlador usuarios.controller.js renderizamos la vista. especificamente en Registrar y pagina, mensaje son los datos que se mostrarn en nuestra vista. 

                    //Mostrar mensaje de confirmaci√≥n

                    res.render('templates/mensaje', {
                        pagina: 'Cuenta Creada Correctamente',
                        mensaje: 'Hemos Enviado un Email de confirmaci√≥n, presiona en el enlace'
                    })

        - Ahora si comenzamos con la parte del envio de emails desde node y para eso se utilizara la dependencia de Nodemailer la cual es la mejor hasta ahorita y la mas completa para node.js y para el envio de emails para simularlo estaremos utilizando una pagina que se llama mailtrap  la cual sirve para probar los emails, checar que lleguen correctamente y que todo funcione bien, antes de hacerlo en un SMTP de algun hosting normal.

            - npm i nodemailer



